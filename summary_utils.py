"""
Utilities for crawling results directories,
generating summary files, plots and reports from the data,
and compressing results.

AUTHOR
    Yoshua Wakeham
    y.wakeham@student.unimelb.edu.au
    yoshua.wakeham@petermac.org
"""
from __future__ import print_function
import os
import csv
import re
import pandas as pd


class RunSummary(object):
    """
    A summary of a simulation run.

    This class is a straightforward wrapper around
    a dictionary of summary fields. It provides various
    methods for scraping summary data from config files,
    results files etc.

    To add a new field or set of fields to the summary
    files generated by this script, add extra methods or
    method calls to this class.
    """
    def __init__(self):
        #self.fields = {}
        self.param_fields = {}
        self.result_fields = {}

    @property
    def param_fields(self):
        return self.__param_fields

    @param_fields.setter
    def param_fields(self, val):
        if not hasattr(self, '__param_fields') and type(val) == dict:
            self.__param_fields = val
        else:
            print("warning: attempting to overwrite RunSummary fields dict.")
            print("         You probably don't want to do this. If you are")
            print("         sure you want to do this, I direct you to")
            print("         the _RunSummary__param_fields attribute.")

    @property
    def result_fields(self):
        return self.__result_fields

    @result_fields.setter
    def result_fields(self, val):
        if not hasattr(self, '__result_fields') and type(val) == dict:
            self.__result_fields = val
        else:
            print("warning: attempting to overwrite RunSummary fields dict.")
            print("         You probably don't want to do this. If you are")
            print("         sure you want to do this, I direct you to")
            print("         the _RunSummary__result_fields attribute.")

    @property
    def fields(self):
        f = self.param_fields.copy()
        f.update(self.result_fields)
        return f

    def add_param_field(self, field_name, value):
        self.param_fields[field_name] = value

    def add_result_field(self, field_name, value):
        self.result_fields[field_name] = value

    def get_field_names(self):
        """
        Get a sorted list of the field names for this summary.

        Get a list of field names for this summary, sorted
        in lexicographic order. (With the exception of 'param_set'
        and 'run_number', which are shifted to the start of the list.)
        These field names can then be passed to csv.DictWriter
        for writing the header of a CSV file.
        """
        field_names = sorted(self.param_fields.keys() + self.result_fields.keys())

        # make sure that param set and run number are first columns in CSV file
        if 'run_number' in field_names:
            field_names.remove('run_number')
            field_names = ['run_number'] + field_names
        if 'param_set' in field_names:
            field_names.remove('param_set')
            field_names = ['param_set'] + field_names

        return field_names

    def add_fields_from_conf_file(self, conf_fpath):
        """
        Add parameters from a configuration file to the summary.

        This method assumes the config file is a list of

            param = val

        assignments (the spaces around the '=' being optional).

        Note that this method hardcodes the list of parameters
        to be added to the summary.
        """
        params_to_store = ['pro', 'die', 'mut', 'qui',
                           'prob_mut_pos', 'prob_mut_neg',
                           'prob_inc_mut', 'prob_dec_mut',
                           'driver_quantile', 'killer_quantile',
                           'beneficial_quantile', 'deleterious_quantile']

        with open(conf_fpath) as conf_file:
            pattern = r"(?P<param>[^\s]+)[\s]*=[\s]*(?P<val>[^\s]+)"
            for line in conf_file:
                match = re.search(pattern, line)
                line_dict = match.groupdict()
                line_param = line_dict['param']
                if line_param in params_to_store:
                    self.add_param_field(line_param, line_dict['val'])

        # for param in params_to_store:
            # if param not in self.fields:
                # print("warning: config file missing expected parameter '{}'".format(param))

        # rename initial prolif and mutation rates
        self.add_param_field('prolif_init', self.param_fields.pop('pro'))
        self.add_param_field('mut_init', self.param_fields.pop('mut'))

    def add_fields_from_run_dir(self, run_dir):
        """
        Add fields to summary from files contained in a replicate run directory.
        """
        results_fpath = os.path.join(run_dir, 'results.txt')
        if not os.path.isfile(results_fpath):
            raise IOError("cannot find results for run_dir: " + run_dir)
        self.add_result_fields_from_csv_file(results_fpath, delim='\t')

        stats_fpath = os.path.join(run_dir, 'stats.txt')
        if not os.path.isfile(stats_fpath):
            raise IOError("cannot find clone stats for run_dir: " + run_dir)
        self.add_result_fields_from_clone_stats(stats_fpath, delim='\t')

    def add_result_fields_from_csv_file(self, fpath, delim=','):
        """
        Add all fields in a csv file to the run summary.

        This assumes that every field in the CSV file should
        be stored to the summary. It will also only take values
        from the first row of the file. Any later rows will be ignored!
        """
        with open(fpath) as results_f:
            reader = csv.DictReader(results_f, delimiter=delim)
            row = next(reader)
            for field, val in row.items():
                self.add_result_field(field, val)

    def add_result_fields_from_clone_stats(self, stats_fpath, delim='\t'):
        """
        Add summary fields computed from the clone statistics file.
        """
        with open(stats_fpath) as stats_file:
            reader = csv.DictReader(stats_file, delimiter=delim)

            tumour_size = 0
            dominant_clone_size = 0
            agg_prolif = 0.0
            agg_mut = 0.0
            nclones = 0

            for row in reader:
                clone_size = int(row['Clone_size'])
                tumour_size += clone_size
                if clone_size > dominant_clone_size:
                    dominant_clone_size = clone_size

                agg_prolif += float(row['Proliferation_Rate'])
                agg_mut += float(row['Mutation_Rate'])
                nclones += 1

        self.add_result_field('prolif_final_avg', agg_prolif/nclones)
        self.add_result_field('mut_final_avg', agg_mut/nclones)
        self.add_result_field('dom_clone_proportion', float(dominant_clone_size)/tumour_size)


def write_summaries_to_file(summaries, summary_fpath):
    """
    Write a summary file for an entire group of simulations.
    """
    summ_fields = summaries[0].get_field_names()

    with open(summary_fpath, 'w') as summ_file:
        writer = csv.DictWriter(summ_file, fieldnames=summ_fields)
        writer.writeheader()
        for summary in summaries:
            writer.writerow(summary.fields)
